<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SWAT Breach FPS (CQB + Dynamic Targets)</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; }
    canvas { display:block; }
    #ui {
      position: fixed; left: 12px; top: 12px;
      font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: #fff;
      background: rgba(0,0,0,0.55);
      padding: 10px 12px;
      border-radius: 10px;
      user-select: none;
    }
    #center {
      position: fixed; left: 50%; top: 50%;
      transform: translate(-50%,-50%);
      width: 10px; height: 10px;
      pointer-events: none;
    }
    #center:before, #center:after {
      content:""; position:absolute; left:50%; top:50%;
      background: rgba(255,255,255,0.9);
      transform: translate(-50%,-50%);
      border-radius: 1px;
    }
    #center:before { width: 10px; height: 2px; }
    #center:after  { width: 2px; height: 10px; }
    #msg {
      position: fixed; left: 50%; top: 14px;
      transform: translateX(-50%);
      color: #fff;
      font: 12px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: rgba(0,0,0,0.55);
      padding: 8px 10px;
      border-radius: 10px;
      display:none;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="ui">
    <div><b>SWAT Breach FPS</b></div>
    <div>Click to lock mouse</div>
    <div>WASD move | Mouse look | LMB shoot | R reload | L laser | Shift sprint | Space jump | G reset</div>
    <div id="hud"></div>
  </div>
  <div id="center"></div>
  <div id="msg"></div>

<script type="module">
import * as THREE from "three";
import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";

////////////////////////////////////////////////////////////
// Setup
////////////////////////////////////////////////////////////
const hudEl = document.getElementById("hud");
const msgEl = document.getElementById("msg");

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.15; // brighter
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // softer shadows
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0c12);
scene.fog = new THREE.Fog(0x0a0c12, 7, 65);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 220);
camera.position.set(0, 1.7, 6);

const controls = new PointerLockControls(camera, document.body);
document.body.addEventListener("click", () => controls.lock());

function flashMsg(text, ms=1200) {
  msgEl.textContent = text;
  msgEl.style.display = "block";
  clearTimeout(flashMsg._t);
  flashMsg._t = setTimeout(()=> msgEl.style.display="none", ms);
}

////////////////////////////////////////////////////////////
// Lighting (more “practical” CQB)
////////////////////////////////////////////////////////////
const hemi = new THREE.HemisphereLight(0x93a9ff, 0x1a0f08, 0.55);
scene.add(hemi);

const key = new THREE.DirectionalLight(0xffffff, 1.0);
key.position.set(10, 18, 8);
key.castShadow = true;
key.shadow.mapSize.set(2048, 2048);
key.shadow.camera.left = -30;
key.shadow.camera.right = 30;
key.shadow.camera.top = 30;
key.shadow.camera.bottom = -30;
scene.add(key);

// subtle ambient fill so corners aren’t dead black
scene.add(new THREE.AmbientLight(0x2a3244, 0.35));

// Ceiling panel lights + emissive fixtures
function addPanelLight(x,z, color=0xfff0d6, intensity=3.0) {
  const light = new THREE.PointLight(color, intensity, 14, 2);
  light.position.set(x, 3.05, z);
  scene.add(light);

  const panel = new THREE.Mesh(
    new THREE.BoxGeometry(1.2, 0.08, 0.6),
    new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: color,
      emissiveIntensity: 2.3,
      roughness: 0.2,
      metalness: 0.0
    })
  );
  panel.position.copy(light.position);
  panel.position.y += 0.05;
  scene.add(panel);
}
addPanelLight(0, 7);
addPanelLight(0, -1);
addPanelLight(6, -1);
addPanelLight(-6, -1);
addPanelLight(0, -9);
addPanelLight(-6, -9);
addPanelLight(6, -9);
addPanelLight(0, -18, 0xd5e1ff, 2.6);

// Emissive strip accents (adds vibe without postprocessing)
function addStrip(x,y,z, w,d, color=0x6aa6ff, emiss=1.2) {
  const strip = new THREE.Mesh(
    new THREE.BoxGeometry(w, 0.03, d),
    new THREE.MeshStandardMaterial({
      color: 0x101318,
      emissive: color,
      emissiveIntensity: emiss,
      roughness: 0.4,
      metalness: 0.2
    })
  );
  strip.position.set(x,y,z);
  scene.add(strip);
}
addStrip(0, 1.05, 8.8, 18, 0.05, 0x355dff, 0.9);
addStrip(0, 1.05, -7.5, 14, 0.05, 0x6a8bff, 0.8);
addStrip(0, 1.05, -24.5, 18, 0.05, 0x355dff, 0.9);

// SWAT siren lights (animated later)
const sirenRed = new THREE.PointLight(0xff3652, 1.1, 9, 1.6);
const sirenBlue = new THREE.PointLight(0x3d7bff, 1.1, 9, 1.6);
sirenRed.position.set(-1.6, 2.6, 7.4);
sirenBlue.position.set(1.6, 2.6, 7.4);
scene.add(sirenRed, sirenBlue);

////////////////////////////////////////////////////////////
// Materials
////////////////////////////////////////////////////////////
const matWall = new THREE.MeshStandardMaterial({ color: 0x2a2f3b, roughness: 0.96, metalness: 0.02 });
const matFloor = new THREE.MeshStandardMaterial({ color: 0x171b22, roughness: 0.85, metalness: 0.12 });
const matTrim = new THREE.MeshStandardMaterial({ color: 0x0f1218, roughness: 0.5, metalness: 0.55 });
const matWood = new THREE.MeshStandardMaterial({ color: 0x5a402c, roughness: 0.78, metalness: 0.05 });
const matFabric = new THREE.MeshStandardMaterial({ color: 0x2a3a35, roughness: 0.98, metalness: 0.0 });
const matMetal = new THREE.MeshStandardMaterial({ color: 0x3c424a, roughness: 0.35, metalness: 0.9 });
const matTarget = new THREE.MeshStandardMaterial({ color: 0xb92a2a, roughness: 0.55, metalness: 0.05 });
const matDoor = new THREE.MeshStandardMaterial({ color: 0x20242d, roughness: 0.5, metalness: 0.65 });
const matConcrete = new THREE.MeshStandardMaterial({ color: 0x1b2029, roughness: 0.95, metalness: 0.05 });
const matAccent = new THREE.MeshStandardMaterial({ color: 0x1a2536, roughness: 0.6, metalness: 0.3, emissive: 0x1c335f, emissiveIntensity: 0.15 });

////////////////////////////////////////////////////////////
// World + Colliders
////////////////////////////////////////////////////////////
const world = new THREE.Group();
scene.add(world);

// Colliders are AABBs (Box3)
const colliders = [];
const animatedProps = [];

function addColliderFromBox(center, size, tag="") {
  const half = size.clone().multiplyScalar(0.5);
  const box = new THREE.Box3(
    center.clone().sub(half),
    center.clone().add(half)
  );
  colliders.push({ box, tag });
}

// Build mesh helper
function addBoxMesh(w,h,d, x,y,z, mat, cast=false, recv=true) {
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
  mesh.position.set(x,y,z);
  mesh.castShadow = cast;
  mesh.receiveShadow = recv;
  world.add(mesh);
  return mesh;
}

// Add box as both mesh + collider
function addBox(w,h,d, x,y,z, mat, cast=false, recv=true, tag="") {
  addBoxMesh(w,h,d,x,y,z,mat,cast,recv);
  addColliderFromBox(new THREE.Vector3(x,y,z), new THREE.Vector3(w,h,d), tag);
}

////////////////////////////////////////////////////////////
// Map: SWAT training house (garage + ops + alley)
////////////////////////////////////////////////////////////

// Floor slab (visual only)
addBoxMesh(26, 0.2, 34, 0, -0.1, -8, matFloor, false, true);
addBoxMesh(6, 0.05, 22, 0, 0.01, -8, matConcrete, false, true);

// Perimeter walls (front split for entry)
addBox(10, 3.2, 0.4, -8, 1.6, 9, matWall, false, true, "wall");
addBox(10, 3.2, 0.4,  8, 1.6, 9, matWall, false, true, "wall");
addBox(26, 3.2, 0.4,  0, 1.6, -25, matWall, false, true, "wall");
addBox(0.4, 3.2, 34, -13, 1.6, -8, matWall, false, true, "wall");
addBox(0.4, 3.2, 34,  13, 1.6, -8, matWall, false, true, "wall");

// Interior structure: lobby divider + central corridors
addBox(6, 3.2, 0.4, 0, 1.6, 4, matWall, false, true, "wall");
addBox(0.4, 3.2, 6, -4, 1.6, 6, matWall, false, true, "wall");
addBox(0.4, 3.2, 6, -4, 1.6, -4, matWall, false, true, "wall");
addBox(0.4, 3.2, 7,  4, 1.6, 6.5, matWall, false, true, "wall");
addBox(0.4, 3.2, 8,  4, 1.6, -4, matWall, false, true, "wall");
addBox(9, 3.2, 0.4, -8.5, 1.6, 1.5, matWall, false, true, "wall");
addBox(9, 3.2, 0.4,  8.5, 1.6, -1, matWall, false, true, "wall");

// Rear cross hall + alley chicanes
addBox(12, 3.2, 0.4, 0, 1.6, -14, matWall, false, true, "wall");
addBox(0.4, 3.2, 9, 0, 1.6, -20, matWall, false, true, "wall");
addBox(6, 3.2, 0.4, -7, 1.6, -6, matWall, false, true, "wall");
addBox(6, 3.2, 0.4,  7, 1.6, -10, matWall, false, true, "wall");

// Garage bay and ops room partitions
addBox(0.4, 3.2, 7, 9, 1.6, 5.5, matWall, false, true, "wall");
addBox(4, 3.2, 0.4, 11, 1.6, 2, matWall, false, true, "wall");
addBox(0.4, 3.2, 7, -9, 1.6, 5.5, matWall, false, true, "wall");
addBox(4, 3.2, 0.4, -11, 1.6, 2, matWall, false, true, "wall");

// Doorframe trim (decor only)
addBoxMesh(2.2, 0.2, 0.2, -8.5, 2.7, 1.5, matTrim, false, true);
addBoxMesh(2.2, 0.2, 0.2,  8.5, 2.7, -1, matTrim, false, true);

// Baseboard trim (decor)
addBoxMesh(26, 0.15, 0.12, 0, 0.12,  8.9, matTrim, false, true);
addBoxMesh(26, 0.15, 0.12, 0, 0.12, -24.9, matTrim, false, true);
addBoxMesh(0.12, 0.15, 34,  12.9, 0.12, -8, matTrim, false, true);
addBoxMesh(0.12, 0.15, 34, -12.9, 0.12, -8, matTrim, false, true);

////////////////////////////////////////////////////////////
// Furniture props (and real colliders)
////////////////////////////////////////////////////////////

function addTable(x,z, rot=0) {
  const g = new THREE.Group();

  const top = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.08, 0.9), matWood);
  top.position.set(0, 0.78, 0);
  top.castShadow = true; top.receiveShadow = true;
  g.add(top);

  const legGeo = new THREE.BoxGeometry(0.08, 0.75, 0.08);
  const legs = [
    [-0.82, 0.38, -0.38],
    [ 0.82, 0.38, -0.38],
    [-0.82, 0.38,  0.38],
    [ 0.82, 0.38,  0.38],
  ];
  for (const [lx,ly,lz] of legs) {
    const leg = new THREE.Mesh(legGeo, matTrim);
    leg.position.set(lx, ly, lz);
    leg.castShadow = true;
    g.add(leg);
  }

  g.position.set(x, 0, z);
  g.rotation.y = rot;
  world.add(g);

  // collider: one simple box around table
  addColliderFromBox(new THREE.Vector3(x, 0.45, z), new THREE.Vector3(1.9, 0.95, 1.0), "table");
}

function addChair(x,z, rot=0) {
  const g = new THREE.Group();

  const seat = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.07, 0.55), matWood);
  seat.position.set(0, 0.45, 0);
  seat.castShadow = true; seat.receiveShadow = true;
  g.add(seat);

  const back = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.55, 0.07), matWood);
  back.position.set(0, 0.75, -0.24);
  back.castShadow = true;
  g.add(back);

  const legGeo = new THREE.BoxGeometry(0.06, 0.45, 0.06);
  const legs = [
    [-0.23, 0.22, -0.23],
    [ 0.23, 0.22, -0.23],
    [-0.23, 0.22,  0.23],
    [ 0.23, 0.22,  0.23],
  ];
  for (const [lx,ly,lz] of legs) {
    const leg = new THREE.Mesh(legGeo, matTrim);
    leg.position.set(lx, ly, lz);
    leg.castShadow = true;
    g.add(leg);
  }

  g.position.set(x, 0, z);
  g.rotation.y = rot;
  world.add(g);

  addColliderFromBox(new THREE.Vector3(x, 0.5, z), new THREE.Vector3(0.7, 1.2, 0.7), "chair");
}

function addShelf(x,z, rot=0) {
  const g = new THREE.Group();

  const frame = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 0.35), matMetal);
  frame.position.set(0, 0.9, 0);
  frame.castShadow = true; frame.receiveShadow = true;
  g.add(frame);

  // shelves (emissive label strips)
  for (let i=0;i<3;i++) {
    const s = new THREE.Mesh(
      new THREE.BoxGeometry(1.05, 0.05, 0.32),
      new THREE.MeshStandardMaterial({
        color: 0x151821,
        emissive: 0x0b2a5f,
        emissiveIntensity: 0.4,
        roughness: 0.6,
        metalness: 0.3
      })
    );
    s.position.set(0, 0.4 + i*0.55, 0);
    g.add(s);
  }

  g.position.set(x, 0, z);
  g.rotation.y = rot;
  world.add(g);

  addColliderFromBox(new THREE.Vector3(x, 0.9, z), new THREE.Vector3(1.25, 1.9, 0.45), "shelf");
}

function addCouch(x,z, rot=0) {
  const g = new THREE.Group();

  const base = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.35, 0.85), matFabric);
  base.position.set(0, 0.18, 0);
  base.castShadow = true; base.receiveShadow = true;
  g.add(base);

  const back = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.75, 0.18), matFabric);
  back.position.set(0, 0.62, -0.33);
  back.castShadow = true;
  g.add(back);

  const armL = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.55, 0.85), matFabric);
  armL.position.set(-0.86, 0.32, 0);
  armL.castShadow = true;
  g.add(armL);

  const armR = armL.clone();
  armR.position.set(0.86, 0.32, 0);
  g.add(armR);

  g.position.set(x, 0, z);
  g.rotation.y = rot;
  world.add(g);

  addColliderFromBox(new THREE.Vector3(x, 0.55, z), new THREE.Vector3(2.05, 1.2, 0.95), "couch");
}

function addBarrel(x,z) {
  const mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.38, 0.95, 18), matMetal);
  mesh.position.set(x, 0.48, z);
  mesh.castShadow = true; mesh.receiveShadow = true;
  world.add(mesh);

  addColliderFromBox(new THREE.Vector3(x, 0.48, z), new THREE.Vector3(0.8, 1.05, 0.8), "barrel");
}

function addCrate(x,z) {
  addBox(1.2, 1.2, 1.2, x, 0.6, z, matTrim, true, true, "crate");
}

function addDoor(x,z, rot=0) {
  const g = new THREE.Group();
  const frame = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.4, 0.12), matTrim);
  frame.position.set(0, 1.2, 0);
  g.add(frame);

  const door = new THREE.Mesh(new THREE.BoxGeometry(0.9, 2.2, 0.08), matDoor);
  door.position.set(0.1, 1.1, 0.06);
  g.add(door);

  g.position.set(x, 0, z);
  g.rotation.y = rot;
  world.add(g);
}

function addFan(x,z) {
  const g = new THREE.Group();
  const hub = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.08, 12), matMetal);
  hub.rotation.x = Math.PI/2;
  g.add(hub);

  for (let i=0;i<3;i++) {
    const blade = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.03, 0.1), matMetal);
    blade.position.set(0.4, 0, 0);
    blade.rotation.z = i * (Math.PI * 2 / 3);
    g.add(blade);
  }
  g.position.set(x, 2.7, z);
  world.add(g);
  animatedProps.push({ type: "fan", mesh: g, speed: 3.2 + Math.random()*0.6 });
}

function addLocker(x,z, rot=0) {
  const body = new THREE.Mesh(new THREE.BoxGeometry(1.1, 2.2, 0.5), matAccent);
  body.position.set(x, 1.1, z);
  body.rotation.y = rot;
  body.castShadow = true;
  world.add(body);
  addColliderFromBox(new THREE.Vector3(x, 1.1, z), new THREE.Vector3(1.1, 2.2, 0.5), "locker");
}

// Place furniture into rooms (feels like a real space)
addTable(-9.4, 4.6, Math.PI * 0.1);
addChair(-10.5, 4.2, Math.PI * 0.35);
addChair(-8.6, 4.2, -Math.PI * 0.15);

addShelf(9.8, 1.0, Math.PI * 0.5);
addBarrel(9.0, -2.5);
addBarrel(10.4, -3.0);

addCouch(-9.2, -12.8, Math.PI * 0.5);
addTable(-7.6, -12.2, Math.PI * 0.55);
addChair(-6.7, -11.4, Math.PI * 0.8);

addCrate(-1.5, -2);
addCrate( 2.5, -8);
addCrate( 1.2, -16);
addCrate(-8.2, -18);
addCrate( 8.5, -14);

addDoor(-8.5, 1.5, Math.PI/2);
addDoor(8.5, -1, -Math.PI/2);
addDoor(0, 4, 0);
addFan(0, -6);
addFan(6, -18);
addLocker(-11, 3.5);
addLocker(11, 0.5, Math.PI);

////////////////////////////////////////////////////////////
// Targets
////////////////////////////////////////////////////////////
const targets = [];
let score = 0;
let streak = 0;
let bestStreak = 0;

function registerTargetMesh(mesh, target) {
  mesh.userData.target = target;
}

function addTarget(x, z, options = {}) {
  const t = new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.35,0.08, 20), matTarget);
  t.rotation.x = Math.PI/2;
  t.position.set(x, 1.6, z);
  t.castShadow = true;
  world.add(t);

  const target = {
    mesh: t,
    alive: true,
    moving: false,
    respawnDelay: options.respawnDelay ?? 5,
    baseScore: options.baseScore ?? 50
  };
  registerTargetMesh(t, target);
  targets.push(target);
}

function addMovingTarget(path, speed = 1.6) {
  const g = new THREE.Group();
  const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.25), matTarget);
  torso.position.set(0, 0.9, 0);
  torso.castShadow = true;
  g.add(torso);

  const head = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 0.25, 12), matTarget);
  head.position.set(0, 1.35, 0);
  head.castShadow = true;
  g.add(head);

  g.position.copy(path[0]);
  g.position.y = 1.6;
  world.add(g);

  const target = {
    mesh: g,
    alive: true,
    moving: true,
    path,
    speed,
    t: 0,
    respawnDelay: 4,
    baseScore: 90
  };
  registerTargetMesh(g, target);
  registerTargetMesh(torso, target);
  registerTargetMesh(head, target);
  targets.push(target);
}

addTarget(-2.5, -22);
addTarget( 0.5, -22);
addTarget( 3.5, -22);
addTarget(-10.5, -4.5, { respawnDelay: 7 });
addTarget( 10.5, -6.5, { respawnDelay: 7 });

addMovingTarget([
  new THREE.Vector3(-1, 0, -4),
  new THREE.Vector3(3, 0, -4),
  new THREE.Vector3(3, 0, -10),
  new THREE.Vector3(-1, 0, -10),
  new THREE.Vector3(-1, 0, -4)
], 1.4);

addMovingTarget([
  new THREE.Vector3(-10.5, 0, 6),
  new THREE.Vector3(-10.5, 0, 2),
  new THREE.Vector3(-6.5, 0, 2),
  new THREE.Vector3(-10.5, 0, 6)
], 1.2);

addMovingTarget([
  new THREE.Vector3(9.5, 0, 6),
  new THREE.Vector3(9.5, 0, 1.5),
  new THREE.Vector3(6.2, 0, 1.5),
  new THREE.Vector3(9.5, 0, 6)
], 1.3);

////////////////////////////////////////////////////////////
// Player physics (better collision, less tunneling)
////////////////////////////////////////////////////////////
const player = {
  pos: new THREE.Vector3(0, 1.7, 6),
  vel: new THREE.Vector3(0, 0, 0),
  radius: 0.35,
  height: 1.7,
  onGround: false
};

const keys = { w:false,a:false,s:false,d:false, shift:false, space:false };
addEventListener("keydown", (e)=>{
  if (e.code === "KeyW") keys.w = true;
  if (e.code === "KeyA") keys.a = true;
  if (e.code === "KeyS") keys.s = true;
  if (e.code === "KeyD") keys.d = true;
  if (e.code === "ShiftLeft" || e.code === "ShiftRight") keys.shift = true;
  if (e.code === "Space") keys.space = true;

  if (e.code === "KeyR") reload();
  if (e.code === "KeyL") toggleLaser();
  if (e.code === "KeyG") resetScenario();
});
addEventListener("keyup", (e)=>{
  if (e.code === "KeyW") keys.w = false;
  if (e.code === "KeyA") keys.a = false;
  if (e.code === "KeyS") keys.s = false;
  if (e.code === "KeyD") keys.d = false;
  if (e.code === "ShiftLeft" || e.code === "ShiftRight") keys.shift = false;
  if (e.code === "Space") keys.space = false;
});

// resolve collisions in XZ using AABB push-out
function pushOutXZ(p) {
  for (const c of colliders) {
    const b = c.box;

    // vertical overlap check (player as vertical cylinder)
    const playerBottom = p.y - player.height;
    const playerTop = p.y;
    if (playerTop < b.min.y || playerBottom > b.max.y) continue;

    const cx = THREE.MathUtils.clamp(p.x, b.min.x, b.max.x);
    const cz = THREE.MathUtils.clamp(p.z, b.min.z, b.max.z);

    const dx = p.x - cx;
    const dz = p.z - cz;
    const dist2 = dx*dx + dz*dz;

    if (dist2 < player.radius*player.radius) {
      const dist = Math.max(Math.sqrt(dist2), 1e-6);
      const push = (player.radius - dist);
      p.x += (dx/dist) * push;
      p.z += (dz/dist) * push;
    }
  }
}

function moveWithCollisions(dt) {
  // ground plane y = 0
  player.onGround = false;

  // step movement to prevent tunneling
  const horizSpeed = Math.hypot(player.vel.x, player.vel.z);
  const stepLen = player.radius * 0.45;
  const steps = Math.max(1, Math.ceil((horizSpeed * dt) / stepLen));
  const sdt = dt / steps;

  for (let i=0;i<steps;i++) {
    // integrate
    player.pos.x += player.vel.x * sdt;
    player.pos.z += player.vel.z * sdt;

    // collide XZ
    pushOutXZ(player.pos);

    // integrate Y
    player.pos.y += player.vel.y * sdt;

    // ground clamp
    if (player.pos.y < player.height) {
      player.pos.y = player.height;
      player.vel.y = 0;
      player.onGround = true;
    }

    // also prevent head going through ceilings by crude clamp:
    // if player is inside a collider vertically, push them down slightly
    for (const c of colliders) {
      const b = c.box;
      const cx = THREE.MathUtils.clamp(player.pos.x, b.min.x, b.max.x);
      const cz = THREE.MathUtils.clamp(player.pos.z, b.min.z, b.max.z);
      const dx = player.pos.x - cx;
      const dz = player.pos.z - cz;
      const dist2 = dx*dx + dz*dz;
      if (dist2 < player.radius*player.radius) {
        // if our head is above collider top, ignore; else, try push down
        if (player.pos.y > b.min.y && player.pos.y < b.max.y + player.height * 0.1) {
          // gentle nudge up or down based on penetration
          // (keeps you from "floating" onto shelves incorrectly)
          if (player.pos.y - player.height < b.max.y && player.vel.y < 0) {
            player.pos.y = b.max.y + player.height + 0.001;
            player.vel.y = 0;
            player.onGround = true;
          }
        }
      }
    }
  }
}

////////////////////////////////////////////////////////////
// Weapon (M4-ish placeholder + recoil)
////////////////////////////////////////////////////////////
const gun = new THREE.Group();
camera.add(gun);
scene.add(camera);

const gunBody = new THREE.Mesh(
  new THREE.BoxGeometry(0.22, 0.14, 0.6),
  new THREE.MeshStandardMaterial({ color: 0x141a22, roughness: 0.32, metalness: 0.75 })
);
gunBody.position.set(0.18, -0.18, -0.55);
gun.add(gunBody);

const gunBarrel = new THREE.Mesh(
  new THREE.CylinderGeometry(0.02, 0.02, 0.45, 12),
  new THREE.MeshStandardMaterial({ color: 0x0e1116, roughness: 0.22, metalness: 0.95 })
);
gunBarrel.rotation.x = Math.PI/2;
gunBarrel.position.set(0.18, -0.16, -0.85);
gun.add(gunBarrel);

const gunStock = new THREE.Mesh(
  new THREE.BoxGeometry(0.18, 0.12, 0.26),
  new THREE.MeshStandardMaterial({ color: 0x0f1218, roughness: 0.55, metalness: 0.55 })
);
gunStock.position.set(0.18, -0.18, -0.25);
gun.add(gunStock);

const muzzle = new THREE.Object3D();
muzzle.position.set(0.18, -0.16, -1.05);
gun.add(muzzle);

const flash = new THREE.Mesh(
  new THREE.PlaneGeometry(0.12, 0.12),
  new THREE.MeshStandardMaterial({ color: 0xfff2c6, emissive: 0xffc06a, emissiveIntensity: 3, transparent:true, opacity:0 })
);
flash.position.set(0.18, -0.16, -1.06);
gun.add(flash);

let recoil = 0;

////////////////////////////////////////////////////////////
// Laser (IR-ish faint line)
////////////////////////////////////////////////////////////
let laserOn = true;
const laserMat = new THREE.LineBasicMaterial({ color: 0xff3b3b, transparent:true, opacity: 0.16 });
const laserGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,0,-20)]);
const laserLine = new THREE.Line(laserGeom, laserMat);
gun.add(laserLine);

function toggleLaser() {
  laserOn = !laserOn;
  laserLine.visible = laserOn;
  flashMsg(laserOn ? "Laser: ON" : "Laser: OFF");
}

////////////////////////////////////////////////////////////
// Shooting (hitscan)
////////////////////////////////////////////////////////////
const raycaster = new THREE.Raycaster();

let ammoMax = 30;
let ammo = ammoMax;
let reserve = 120;
let canShoot = true;

function reload() {
  if (ammo === ammoMax) return;
  if (reserve <= 0) return;
  const need = ammoMax - ammo;
  const take = Math.min(need, reserve);
  reserve -= take;
  ammo += take;
  flashMsg("Reload");
}

function resetScenario() {
  targets.forEach((t) => {
    t.alive = true;
    t.mesh.visible = true;
    t.respawnAt = null;
    if (!t.moving) {
      t.mesh.material = matTarget;
    } else {
      t.t = 0;
      t.mesh.position.copy(t.path[0]);
      t.mesh.position.y = 1.6;
      t.mesh.traverse((child) => {
        if (child.isMesh) child.material = matTarget;
      });
    }
  });
  score = 0;
  streak = 0;
  bestStreak = 0;
  ammo = ammoMax;
  reserve = 120;
  flashMsg("Scenario Reset");
}

function shoot() {
  if (!canShoot || ammo <= 0) return;

  ammo--;
  canShoot = false;
  setTimeout(()=> canShoot = true, 85); // slightly faster

  recoil = Math.min(recoil + 0.085, 0.30);
  flash.material.opacity = 1;
  setTimeout(()=> flash.material.opacity = 0, 35);

  raycaster.setFromCamera(new THREE.Vector2(0,0), camera);

  const hits = raycaster.intersectObjects(world.children, true);

  if (hits.length) {
    const hitObj = hits[0].object;

    const t = hitObj.userData.target;
    if (t && t.alive) {
      t.alive = false;
      t.mesh.visible = false;
      t.respawnAt = performance.now() + t.respawnDelay * 1000;
      streak += 1;
      bestStreak = Math.max(bestStreak, streak);
      score += t.baseScore + Math.min(25, streak * 3);
      flashMsg(t.moving ? "Hostile Down!" : "Hit!");
    } else {
      streak = 0;
    }

    // impact puff
    const p = hits[0].point;
    const n = hits[0].face?.normal?.clone() ?? new THREE.Vector3(0,1,0);
    n.transformDirection(hitObj.matrixWorld);

    const puff = new THREE.Mesh(
      new THREE.PlaneGeometry(0.14, 0.14),
      new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xaaaaaa, emissiveIntensity: 0.15, transparent:true, opacity: 0.7 })
    );
    puff.position.copy(p).add(n.multiplyScalar(0.02));
    puff.lookAt(p.clone().add(n));
    world.add(puff);
    setTimeout(()=> world.remove(puff), 420);
  } else {
    streak = 0;
  }
}

addEventListener("mousedown", (e)=>{
  if (e.button === 0 && controls.isLocked) shoot();
});

////////////////////////////////////////////////////////////
// Laser update: stop on first hit
////////////////////////////////////////////////////////////
function updateLaser() {
  if (!laserOn) return;

  const start = new THREE.Vector3();
  muzzle.getWorldPosition(start);

  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);

  raycaster.set(start, dir);
  raycaster.far = 45;

  const hits = raycaster.intersectObjects(world.children, true);

  const end = start.clone().add(dir.clone().multiplyScalar(45));
  if (hits.length) end.copy(hits[0].point);

  const gunInv = new THREE.Matrix4().copy(gun.matrixWorld).invert();
  const sL = start.clone().applyMatrix4(gunInv);
  const eL = end.clone().applyMatrix4(gunInv);

  const arr = laserLine.geometry.attributes.position.array;
  arr[0]=sL.x; arr[1]=sL.y; arr[2]=sL.z;
  arr[3]=eL.x; arr[4]=eL.y; arr[5]=eL.z;
  laserLine.geometry.attributes.position.needsUpdate = true;
}

////////////////////////////////////////////////////////////
// Loop
////////////////////////////////////////////////////////////
let last = performance.now();

function tick(now) {
  requestAnimationFrame(tick);
  const dt = Math.min((now - last) / 1000, 0.033);
  last = now;

  // movement
  const baseSpeed = 3.8;
  const sprint = 6.2;
  const speed = (keys.shift ? sprint : baseSpeed);

  const wish = new THREE.Vector3(
    (keys.d ? 1 : 0) - (keys.a ? 1 : 0),
    0,
    (keys.s ? 1 : 0) - (keys.w ? 1 : 0)
  );

  if (controls.isLocked) {
    if (wish.lengthSq() > 0) wish.normalize().multiplyScalar(speed);

    // camera yaw movement
    const yaw = new THREE.Euler(0, camera.rotation.y, 0, "YXZ");
    wish.applyEuler(yaw);

    player.vel.x = wish.x;
    player.vel.z = wish.z;

    // gravity
    player.vel.y += -18 * dt;

    // jump
    if (keys.space && player.onGround) {
      player.vel.y = 6.8;
      player.onGround = false;
    }

    moveWithCollisions(dt);

    controls.getObject().position.copy(player.pos);
  }

  // recoil + sway
  recoil *= 0.86;
  gun.position.set(0,0,0);
  gun.rotation.set(0,0,0);
  gun.position.y = -0.02 + Math.sin(now*0.004) * 0.003;
  gun.position.x =  0.01 + Math.sin(now*0.003) * 0.002;
  gun.position.z =  0.02 + recoil * 0.12;
  gun.rotation.x = -recoil;

  updateLaser();

  // siren pulse + animated props
  const sirenPulse = (Math.sin(now * 0.008) + 1) * 0.5;
  sirenRed.intensity = 0.4 + sirenPulse * 1.2;
  sirenBlue.intensity = 0.4 + (1 - sirenPulse) * 1.2;

  animatedProps.forEach((prop) => {
    if (prop.type === "fan") {
      prop.mesh.rotation.y += prop.speed * dt;
    }
  });

  // moving targets + respawn
  targets.forEach((t) => {
    if (!t.alive && t.respawnAt && now > t.respawnAt) {
      t.alive = true;
      t.mesh.visible = true;
      if (t.moving) {
        t.t = 0;
        t.mesh.position.copy(t.path[0]);
      }
    }

    if (t.alive && t.moving) {
      const segments = t.path.length - 1;
      t.t = (t.t + t.speed * dt) % segments;
      const segIndex = Math.floor(t.t);
      const segT = t.t - segIndex;
      const p0 = t.path[segIndex];
      const p1 = t.path[segIndex + 1];
      t.mesh.position.lerpVectors(p0, p1, segT);
      t.mesh.position.y = 1.6;
      t.mesh.rotation.y = Math.atan2(p1.x - p0.x, p1.z - p0.z);
    }
  });

  // HUD
  const activeTargets = targets.filter(t=>t.alive).length;
  hudEl.textContent = `Ammo: ${ammo}/${ammoMax}  Reserve: ${reserve}  Targets: ${activeTargets}/${targets.length}  Score: ${score}  Streak: ${streak} (Best ${bestStreak})`;

  renderer.render(scene, camera);
}

tick(performance.now());

addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

flashMsg("Click to play • Clear the house");
</script>
</body>
</html>
